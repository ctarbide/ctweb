
<<copyright>>=
# Copyright (c) 2021, C. Tarbide.
# All rights reserved.

# Permission to distribute and use this work for any
# purpose is hereby granted provided this copyright
# notice is included in the copy.  This work is provided
# as is, with no warranty of any kind.

# objective: generate portable Makefiles from a simple
# description language
@

Generate gen-Makefile.awk with a one-liner:

    nofake -R'commands to manually generate' gen-Makefile.nw | sh -eux

<<commands to manually generate>>=
nofake -Rgenerator gen-Makefile.nw > .genmk.awk
nofake -Roperations gen-Makefile.nw | nawk -f .genmk.awk > .genmk.nw
nofake -Rgen-Makefile.awk .genmk.nw gen-Makefile.nw > gen-Makefile.awk
@

Same as above, but more suited for Makefile automation,
"s1" stands for stage 1.

<<actions snippet>>=
=gen-Makefile.awk
,gen-Makefile-s1.nw: gen-Makefile.nw
,	$(NOFAKE) -Rgenerator gen-Makefile.nw \
,	    > .tmp.gen-Makefile-s1.awk
,	$(MV) .tmp.gen-Makefile-s1.awk gen-Makefile-s1.awk
,	$(NOFAKE) -Roperations gen-Makefile.nw | $(AWK) -f gen-Makefile-s1.awk \
,	    > .tmp.gen-Makefile-s1.nw
,	$(MV) .tmp.gen-Makefile-s1.nw gen-Makefile-s1.nw
,	$(CHMOD_0444) gen-Makefile-s1.awk gen-Makefile-s1.nw
,gen-Makefile.awk: gen-Makefile-s1.nw gen-Makefile.nw
,	$(NOFAKE) -Rgen-Makefile.awk gen-Makefile-s1.nw gen-Makefile.nw \
,	    > .tmp.gen-Makefile.awk
,	$(MV) .tmp.gen-Makefile.awk gen-Makefile.awk
,	$(CHMOD_0444) gen-Makefile.awk
@@
@

<<generated by notice>>=
# This file was generated from gen-Makefile.nw.
# Please do not edit.
@

<<read environment variables>>=
genbymsg = ENVIRON["GENERATED_BY_MESSAGE"]
vpath = ENVIRON["VPATH"]
subdir = ENVIRON["SUBDIR"]
top = ENVIRON["TOP"]
objext = ENVIRON["OBJEXT"]
exesuffix = ENVIRON["EXESUFFIX"]
toolsdirprefix = ENVIRON["TOOLSDIRPREFIX"]
@

<<BEGIN>>=
BEGIN{
	<<read environment variables>>
	if (!vpath) vpath = "."
	if (!top) top = "."
	if (!objext) objext = "o"
	maxlinelen = 72
	nerrors = 0
	reading_file = 1
}
END{
	reading_file = 0
	if (nerrors) {
		exit 1
	}
}
@

First element ARGV[0] is the program name (e.g. "nawk").

<<auxiliary functions>>=
function join_ARGV(sep, \
		i, i_len, res) {
	if (ARGC < 2) return ""
	res = ARGV[1]
	i_len = ARGC
	for (i=2; i<i_len; i++) res = res sep ARGV[i]
	return res
}
@

If still reading the file, show errors early since END
pattern will not show them.  If on END pattern, show
early only if there is no current block defined.

<<auxiliary functions>>=
function show_error(errmsg) {
	nerrors++
	if (reading_file) {
		print("# ERROR: " errmsg)
	} else {
		if (cur_block) {
			push_current_block_output("# ERROR: " errmsg)
		} else {
			print("# ERROR: " errmsg)
		}
	}
}
@

<<auxiliary functions>>=
function set_var_from_env_template(var, def, \
		env) {
	env = ENVIRON[var]
	return var "=" (env ? env : def)
}

function join_block_names_by_type(curlinelen, type, \
		res, i, i_len, item, itemlen) {
	res = ""
	i_len = length_block()
	for (i=0; i<i_len; i++) {
		item = get_block(i)
		if (get_block__type(item) != type) {
			continue
		}
		itemlen = length(item)
		curlinelen += 1 + itemlen
		# + 2 to account for the possibility of " \\"
		if ((curlinelen + 2) > maxlinelen) {
			res = res " \\\n    " item
			curlinelen = 4 + itemlen
		} else {
			res = res " " item
		}
	}
	return res
}

function join_c_programs(curlinelen) {
	return join_block_names_by_type(curlinelen, "c-program")
}

function prefix_c_programs(prefix) {
	return prefix join_c_programs(length(prefix))
}

function join_nofake_chunks(curlinelen, \
		res, i, i_len, item, itemlen) {
	res = ""
	i_len = length_chunk()
	for (i=0; i<i_len; i++) {
		item = get_chunk__target(i)
		itemlen = length(item)
		curlinelen += 1 + itemlen
		# + 2 to account for the possibility of " \\"
		if ((curlinelen + 2) > maxlinelen) {
			res = res " \\\n    " item
			curlinelen = 4 + itemlen
		} else {
			res = res " " item
		}
	}
	return res
}

function prefix_nofake_chunks(prefix) {
	return prefix join_nofake_chunks(length(prefix))
}
@

<<filter-out non-primary dependencies>>=
if (type ~ "^(c-object)$") {
	continue
} else if (type ~ "^(nofake)$") {
	# it is common for a nofake chunk target
	# match a primary dependency, just proceed
} else if (!type) {
	# just a plain primary dependency
} else {
	show_error("exhaustion-1: " FILENAME ":" FNR ": type \"" type "\" (filtering out non-primary dependencies)")
	continue
}
@

<<how_many primary dependencies>>=
function how_many_primary_dependencies(block_name, \
		res, i, i_len, item) {
	res = 0
	i_len = length_block_dependency(block_name)
	for (i=0; i<i_len; i++) {
		item = get_block_dependency(block_name, i)
		type = get_block__type(item)
		<<filter-out non-primary dependencies>>
		res++
	}
	return res;
}
@

<<prepend src prefix to item if untyped and can't use vpath>>=
if (!type && !uses_vpath) {
	# just a plain primary dependency that lives
	# in vpath
	item = "'$(SRC_PREFIX)" item "'"
}
@

<<prepend src prefix to item if untyped>>=
if (!type) {
	# just a plain primary dependency that lives
	# in vpath
	item = "'$(SRC_PREFIX)" item "'"
}
@

<<join primary dependencies>>=
function join_primary_dependencies(block_name, curlinelen, uses_vpath, new_line_prefix, \
		res, i, i_len, item, itemlen, type) {
	res = ""
	<<setup new_line_prefix>>
	i_len = length_block_dependency(block_name)
	for (i=0; i<i_len; i++) {
		item = get_block_dependency(block_name, i)
		type = get_block__type(item)
		<<filter-out non-primary dependencies>>
		<<prepend src prefix to item if untyped and can't use vpath>>
		<<concat item to res>>
	}
	return res
}
@

<<prefix primary dependencies>>=
<<how_many primary dependencies>>
<<join primary dependencies>>
function prefix_primary_dependencies(prefix, block_name, uses_vpath, new_line_prefix) {
	return prefix join_primary_dependencies(block_name, length(prefix), uses_vpath, new_line_prefix)
}
@

<<join c-objects>>=
function join_c_objects(block_name, curlinelen, new_line_prefix, \
		res, i, i_len, item, itemlen, type) {
	res = ""
	<<setup new_line_prefix>>
	i_len = length_block_dependency(block_name)
	for (i=0; i<i_len; i++) {
		item = get_block_dependency(block_name, i)
		type = get_block__type(item)
		if (type != "c-object") {
			continue
		}
		sub("\\." objext "$", "", item)
		item = item "." objext
		<<concat item to res>>
	}
	return res
}
@

<<join sources>>=
function join_sources(block_name, curlinelen, new_line_prefix, \
		res, i, i_len, item, itemlen) {
	res = ""
	<<setup new_line_prefix>>
	i_len = length_block_source(block_name)
	for (i=0; i<i_len; i++) {
		item = get_block_source(block_name, i)
		<<concat item to res>>
	}
	return res
}
<<prefix sources>>=
<<join sources>>
function prefix_sources(prefix, block_name, new_line_prefix) {
	return prefix join_sources(block_name, length(prefix), new_line_prefix)
}
@

<<join all nofake sources>>=
function join_all_nofake_sources(curlinelen, uses_vpath, new_line_prefix, \
		block_name, res, i, i_len, j, j_len, item, itemlen, type, visited) {
	res = ""
	<<setup new_line_prefix>>
	j_len = length_block()
	for (j=0; j<j_len; j++) {
		block_name = get_block(j);
		type = get_block__type(block_name)
		if (type !~ /^nofake(-awk)?$/) {
			continue
		}
		i_len = length_block_source(block_name)
		for (i=0; i<i_len; i++) {
			item = get_block_source(block_name, i)
			if (visited[item]++) {
				continue
			}
			type = get_block__type(item)
			<<prepend src prefix to item if untyped and can't use vpath>>
			<<concat item to res>>
		}
	}
	return res
}
<<prefix all nofake sources>>=
<<join all nofake sources>>
function prefix_all_nofake_sources(prefix, uses_vpath, new_line_prefix) {
	return prefix join_all_nofake_sources(length(prefix), uses_vpath, new_line_prefix)
}
@

<<setup new_line_prefix>>=
if (!new_line_prefix) {
	new_line_prefix = "    "
}
new_line_prefix_len = length(new_line_prefix)
@

1 is for the single space separator

<<concat item to res>>=
itemlen = length(item)
curlinelen += 1 + itemlen
# + 2 to account for the possibility of " \\"
if ((curlinelen + 2) > maxlinelen) {
	res = res " \\\n" new_line_prefix item
	curlinelen = new_line_prefix_len + itemlen
} else {
	res = res " " item
}
@

<<join gl0>>=
function join_gl0(curlinelen, new_line_prefix, \
		res, i, i_len, item, itemlen) {
	res = ""
	<<setup new_line_prefix>>
	i_len = length_gl0()
	for (i=0; i<i_len; i++) {
		item = get_gl0(i)
		<<concat item to res>>
	}
	return res
}
<<prefix gl0>>=
<<join gl0>>
function prefix_gl0(prefix, new_line_prefix) {
	return prefix join_gl0(length(prefix), new_line_prefix)
}
@

<<prefix functions>>=
<<prefix gl0>>
<<prefix primary dependencies>>
<<prefix all nofake sources>>
<<prefix sources>>

function prefix_c_objects(prefix, block_name, new_line_prefix) {
	return prefix join_c_objects(block_name, length(prefix), new_line_prefix)
}
@

<<auxiliary functions>>=
<<join c-objects>>
<<prefix functions>>
@

<<type>>=
cur_type = get_block__type(cur_block)
if (cur_type) {
	# type redefinition isn't expected
	show_error("in block \"" cur_block "\", redefining type from " cur_type " to " $2)
} else {
	# setting type for the first time
	set_current_block__type(cur_type = $2)
}
@

<<dependency>>=
if (cur_type ~ /^(c-program|c-object)$/) {
	push_current_block_dependency($2)
} else {
	show_error("exhaustion-3: " FILENAME ":" FNR ": type: " cur_type)
}
@

<<source>>=
if (cur_type ~ /^(nofake(-awk)?|c-program|c-object)$/) {
	push_current_block_source($2)
} else {
	show_error("exhaustion-4: " FILENAME ":" FNR ": type: " cur_type)
}
@

<<chunk>>=
name = $2    # name inside noweb file
target = $3  # output filename of this chunk
if (!target) {
	if (name ~ "^[a-zA-Z0-9_]") {
		target = name
	} else {
		show_error("Cannot determine an appropriate target filename from chunk name \"" name "\".")
	}
}
if (target) {
	if (map_chunk_target_to_block[target]) {
		show_error("chunk target already defined: " target \
			" in block " map_chunk_target_to_block[target])
	} else {
		push_current_block_chunk(name, target)
		push_chunk(name, target)
		map_chunk_target_to_block[target] = cur_block
	}
}
@

<<target-option>>=
target = $2
if (target) {
	option = $3
	if (option) {
		value = $4
		if (length(value)) {
			set_current_block_targetoption(target, option, value)
		} else {
			show_error("value is empty for target-option")
		}
	} else {
		show_error("option is not defined for target-option")
	}
} else {
	show_error("target is not defined for target-option")
}
@

<<finalize internal-vars>>=
push_current_block_output(set_var_from_env_template("BUILD_AWK", "nawk"))
push_current_block_output(set_var_from_env_template("BUILD_MAKEFILE", "Makefile"))
push_current_block_output(vars["OBJEXT"])
push_current_block_output(vars["EXESUFFIX"])
push_current_block_output(vars["SRC_PREFIX"])
push_current_block_output(vars["SRC_INCLUDE"])
push_current_block_output(vars["SUBDIR"])
push_current_block_output(vars["TOP"])
push_current_block_output(vars["NOFAKE"])
push_current_block_output(vars["INSTALL"])
push_current_block_output(vars["C_PROGRAMS"])
push_current_block_output(vars["NOFAKE_SOURCES"])
push_current_block_output(vars["NOFAKE_CHUNKS"])
@

<<regexp matches>>=
/^=[a-zA-Z][a-zA-Z0-9\-_.]*$/ {
	<<match preamble>>
	cur_block = substr($0, 2)
	push_block(cur_block)
	<<match epilog>>
}

/^,/ {
	<<match preamble>>
	push_current_block_output(substr($0, 2))
	<<match epilog>>
}

/^type[ \t]/ {
	<<match preamble>>
	if (cur_block) {
		<<type>>
	} else {
		show_error("orphan type")
	}
	<<match epilog>>
}

/^dependency[ \t]/ {
	<<match preamble>>
	if (cur_block) {
		<<dependency>>
	} else {
		show_error("orphan dependency")
	}
	<<match epilog>>
}

/^source[ \t]/ {
	<<match preamble>>
	if (cur_block) {
		<<source>>
	} else {
		show_error("orphan source")
	}
	<<match epilog>>
}

/^chunk[ \t]/ {
	<<match preamble>>
	if (cur_block) {
		if (cur_type ~ /^nofake(-awk)?$/) {
			<<chunk>>
		} else {
			show_error("exhaustion-5: " FILENAME ":" FNR ": type: " cur_type)
		}
	} else {
		show_error("orphan chunk")
	}
	<<match epilog>>
}

/^target-option[ \t]/ {
	<<match preamble>>
	if (cur_block) {
		if (cur_type ~ /^nofake(-awk)?$/) {
			<<target-option>>
		} else {
			show_error("exhaustion-6: " FILENAME ":" FNR ": type: " cur_type)
		}
	} else {
		show_error("orphan chunk")
	}
	<<match epilog>>
}
@

<<finalize block>>=
if (cur_type == "c-program") {
	<<finalize c-program>>
} else if (cur_type == "nofake") {
	<<finalize nofake>>
} else if (cur_type == "nofake-awk") {
	<<finalize nofake-awk>>
} else if (cur_type == "c-object") {
	<<finalize c-object>>
} else if (cur_type == "internal-vars") {
	<<finalize internal-vars>>
} else if (cur_type) {
	show_error("exhaustion-7: " FILENAME ":" FNR ": type: " cur_type)
} else if (!length_block_output(cur_block)) {
	show_error("type not defined in an empty block")
}
@

<<output block lines>>=
j_len = length_block_output(cur_block)
for (j=0; j<j_len; j++) {
	print get_block_output(cur_block, j)
}
print ""
@

<<END>>=
END{
	print "# automatically generated, please to not edit"
	if (genbymsg) {
		print "# " genbymsg
		print "# input files: " join_ARGV(", ")
		print ""
	}

	tools_prefix = ""

	if (vpath == ".") {
		# in source build
		src = vpath
		if (top == ".") {
			# toplevel
			tools_prefix = "./" toolsdirprefix
		} else {
			tools_prefix = top "/" toolsdirprefix
		}
	} else if (vpath ~ /\// && subdir) {
		# absolute vpath
		src = vpath "/" subdir
		print "VPATH = " src
		tools_prefix = vpath "/" toolsdirprefix
		print ""
	} else if (vpath && subdir && top) {
		# relative vpath
		if (subdir == "." && top == ".") {
			# toplevel
			src = vpath
			print "VPATH = " src
			tools_prefix = vpath "/" toolsdirprefix
		} else {
			src = vpath "/" top "/" subdir
			print "VPATH = " src
			tools_prefix = vpath "/" top "/" toolsdirprefix
		}
		print ""
	} else {
		show_error("Cannot determine VPATH.")
	}

	<<failure exit if error>>

	vars["OBJEXT"] = "OBJEXT = " objext
	vars["EXESUFFIX"] = "EXESUFFIX = " exesuffix
	vars["NOFAKE"] = "NOFAKE = " tools_prefix "nofake"
	vars["INSTALL"] = "INSTALL = " tools_prefix "install.sh"

	vars["C_PROGRAMS"] = prefix_c_programs("C_PROGRAMS =")
	vars["NOFAKE_SOURCES"] = prefix_all_nofake_sources("NOFAKE_SOURCES =", 1)
	vars["NOFAKE_CHUNKS"] = prefix_nofake_chunks("NOFAKE_CHUNKS =")

	if (src == ".") {
		vars["SRC_PREFIX"] = "SRC_PREFIX ="
		vars["SRC_INCLUDE"] = "SRC_INCLUDE = -I."
	} else {
		vars["SRC_PREFIX"] = "SRC_PREFIX = " src "/"
		vars["SRC_INCLUDE"] = "SRC_INCLUDE = -I. -I'" src "'"
	}

	vars["SUBDIR"] = "SUBDIR = " subdir
	vars["TOP"] = "TOP = " top

	h_len = length_block()
	for (h=0; h<h_len; h++) {
		cur_block = get_block(h)
		cur_type = get_block__type(cur_block)
		print "# **************** " cur_block " " (cur_type ? "(type: " cur_type ")" : "(no type)")
		<<finalize block>>
		<<output block lines>>
		<<failure exit if error>>
	}

	if (length_block_output("")) {
		show_error(length_block_output("") " unknown lines (empty)")
		print ""
	}

	if (length_block_output(0)) {
		show_error(length_block_output(0) " unknown lines (0)")
		print ""
	}

	<<failure exit if error>>
}
@

<<auxiliary functions>>=
function mark_as_generated_target(target) {
	generated_targets[target]++
}
function is_generated_target(item) {
	return generated_targets[item]
}
@

<<finalize c-object, source is ok>>=
source = get_block_source(cur_block, 0)
target = cur_block
sub("\\." objext "$", "", target)
target = target "." objext
mark_as_generated_target(target)
if (!is_generated_target(source)) {
	source = "$(SRC_PREFIX)" source
}
push_current_block_output(prefix_primary_dependencies(target ": " source, cur_block, 1, "    "))
push_current_block_output("\t$(CC) $(CFLAGS) $(SRC_INCLUDE) -o " target " '" source "'")
@

<<finalize c-object>>=
source_len = length_block_source(cur_block)
if (source_len == 1) {
	<<finalize c-object, source is ok>>
} else if (source_len) {
	show_error("c-object \"" cur_block "\" expects 1 source, " source_len " provided")
} else {
	show_error("c-object \"" cur_block "\" has no source")
}
@

<<finalize c-program, source is ok>>=
source = get_block_source(cur_block, 0)
obj = source
if (sub(/\.c$/, "." objext, obj)) {
	if (!is_generated_target(obj)) {
		push_current_block_output(prefix_primary_dependencies(obj ": " source, cur_block, 1, "    "))
		if (!is_generated_target(source)) {
			source = "$(SRC_PREFIX)" source
		}
		push_current_block_output("\t$(CC) $(CFLAGS) $(SRC_INCLUDE) -o " obj " '" source "'")
	}
	target = cur_block exesuffix
	mark_as_generated_target(target)
	push_current_block_output(prefix_c_objects(target ": " obj, cur_block, "    "))
	push_current_block_output(prefix_c_objects("\t$(LD) $(LDFLAGS) -o " cur_block " $(LIBS)", cur_block, "\t    ") " " obj)
} else {
	show_error("exhaustion-8: c-program \"" cur_block "\" source: \"" source "\"")
}
@

<<finalize c-program>>=
source_len = length_block_source(cur_block)
if (source_len == 1) {
	<<finalize c-program, source is ok>>
} else if (source_len) {
	show_error("c-program \"" cur_block "\" expects 1 source, " source_len " provided")
} else {
	show_error("c-program \"" cur_block "\" has no source")
}
@

<<finalize nofake: clear and setup gl0 and known sources>>=
for (idx in known_sources) delete known_sources[idx]
clear_gl0()
for (i=0; i<i_len; i++) {
	item = get_block_source(cur_block, i)
	known_sources[item]++
	type = get_block__type(item)
	<<prepend src prefix to item if untyped>>
	push_gl0(item)
}
@

<<finalize nofake chunk recipe commands>>=
if (get_current_block_targetoption(target, "executable")) {
	chmod = "$(CHMOD_0555)"
} else {
	chmod = "$(CHMOD_0444)"
}
push_current_block_output("\t@set -eu; \\")
push_current_block_output("\t    if ! test '(' -e '" target ".stamp' -a -e '" target "' \\")
k_len = length_gl0()
for (k=0; k<k_len; k++) {
	source = get_gl0(k)
	push_current_block_output( \
			  "\t                  -a '" target ".stamp' -nt " source " \\")
}
push_current_block_output("\t            ')'; then \\")
push_current_block_output("\t        set -x; \\")
push_current_block_output(prefix_gl0( \
			  "\t        $(NOFAKE) -R'" name "' $(NOFAKEFLAGS)", \
			  "\t            ") " \\")
push_current_block_output("\t            >'.tmp." target "'; \\")
push_current_block_output("\t        if ! $(CMP) '.tmp." target "' '" target "'; then \\")
push_current_block_output("\t            $(MV) '.tmp." target "' '" target "'; \\")
push_current_block_output("\t            " chmod " '" target "'; \\")
push_current_block_output("\t        else \\")
push_current_block_output("\t            $(RM) '.tmp." target "'; \\")
push_current_block_output("\t        fi; \\")
push_current_block_output("\t        $(TOUCH) '" target ".stamp'; \\")
push_current_block_output("\t    else \\")
push_current_block_output("\t        $(ECHO) 'Target \"" target "\" is up to date.'; \\")
push_current_block_output("\t    fi")
@

<<finalize nofake chunk>>=
push_current_block_output(".STAMP: " target ".stamp")
push_current_block_output(prefix_sources(target ":", cur_block))
<<finalize nofake chunk recipe commands>>
@

<<finalize nofake: loop chunks>>=
for (i=0; i<i_len && nerrors == 0; i++) {
	name = get_current_block_chunk__name(i)
	target = get_current_block_chunk__target(i)
	if (known_sources[target]) {
		show_error("The target and the source are the same: \"" target "\".")
		break
	}
	if (is_generated_target(target)) {
		show_error("The target \"" target "\" is already being generated.");
		break
	}
	mark_as_generated_target(target)
	<<finalize nofake chunk>>
}
<<finalize nofake>>=
i_len = length_block_source(cur_block)
if (i_len) {
	<<finalize nofake: clear and setup gl0 and known sources>>
	i_len = length_block_chunk(cur_block)
	if (!i_len) {
		show_error("There are no chunks defined (thus no targets).")
	}
	<<finalize nofake: loop chunks>>
} else {
	show_error("There are no sources defined to generate the targets.")
}
@

<<finalize nofake-awk: stage 1 source recipe>>=
push_current_block_output(prefix_sources(target ":", cur_block))
push_current_block_output(prefix_sources("\t$(NOFAKE) -Rgenerator", cur_block) " \\")
push_current_block_output("\t    > '.tmp." s1_awk "'")
push_current_block_output("\t$(MV) '.tmp." s1_awk "' '" s1_awk "'")
push_current_block_output(prefix_sources("\t$(NOFAKE) -Roperations", cur_block) " | $(AWK) -f '" s1_awk "' \\")
push_current_block_output("\t    > '.tmp." target "'")
push_current_block_output("\t$(MV) '.tmp." target "' '" target "'")
push_current_block_output("\t$(CHMOD_0444) '" s1_awk "' '" target "'")
@

Same algorithm.

<<finalize nofake-awk: clear and setup gl0 and known sources>>=
<<finalize nofake: clear and setup gl0 and known sources>>
@

<<finalize nofake-awk: setup s1_awk, s1_nw and target vars>>=
s1_prefix = cur_block
if (sub(/\.nw$/, "", s1_prefix)) target = cur_block
else target = s1_prefix "-s1.nw"
s1_awk = s1_prefix "-s1.awk"
s1_nw = target
mark_as_generated_target(s1_awk)
mark_as_generated_target(target)
@

Same algorithm.

<<finalize nofake-awk chunk recipe commands>>=
<<finalize nofake chunk recipe commands>>
@

<<finalize nofake-awk chunk>>=
push_current_block_output(".STAMP: " target ".stamp")
push_current_block_output(target ": " s1_nw)
<<finalize nofake-awk chunk recipe commands>>
@

<<finalize nofake-awk: loop chunks>>=
for (i=0; i<i_len && nerrors == 0; i++) {
	name = get_current_block_chunk__name(i)
	target = get_current_block_chunk__target(i)
	if (known_sources[target]) {
		show_error("The target and the source are the same: \"" target "\".")
		break
	}
	if (is_generated_target(target)) {
		show_error("The target \"" target "\" is already being generated.");
		break
	}
	mark_as_generated_target(target)
	<<finalize nofake-awk chunk>>
}
<<finalize nofake-awk>>=
i_len = length_block_source(cur_block)
if (i_len) {
	<<finalize nofake-awk: clear and setup gl0 and known sources>>
	<<finalize nofake-awk: setup s1_awk, s1_nw and target vars>>
	push_gl0("'" s1_nw "'")
	if (!known_sources[target]) {
		<<finalize nofake-awk: stage 1 source recipe>>
		i_len = length_block_chunk(cur_block)
		if (!i_len) {
			show_error("There are no chunks defined (thus no targets).")
		}
		<<finalize nofake-awk: loop chunks>>
	} else {
		show_error("The target and the source are the same: \"" target "\".")
	}
} else {
	show_error("There are no sources defined to generate the targets.")
}
@

<<regexp matches>>=

/^[ \t]*#/ {
	<<match preamble>>
	# print "# comment: " $0
	<<match epilog>>
}

/^$/ {
	<<match preamble>>
	<<match epilog>>
}

/^@$/ {
	<<match preamble>>
	cur_block = 0
	cur_type = 0
	<<match epilog>>
}

{
	if (!found) {
		print "# warn: unprocessed line: \"" $0 "\""
	} else {
		found = 0
	}
}
@

<<exit with failure message>>=
Exiting with failure due to the presence of errors.
@

<<failure exit if error>>=
if (nerrors) {
	print "\nERROR: <<exit with failure message>>\n"
	exit 1
}
@

<<match preamble>>=
if (nerrors) {
	print "\nERROR: preamble: <<exit with failure message>>\n"
	exit 1
}
@

<<match epilog>>=
if (nerrors) {
	print "\nERROR: epilog: <<exit with failure message>>\n"
	exit 1
} else next
@

<<gen-Makefile.awk>>=
<<generated by notice>>

<<copyright>>

<<BEGIN>>

<<generated>>

<<auxiliary functions>>

<<regexp matches>>

<<END>>

<<op push>>=
if (keys) {
	keys = keys ", "
}
if (gfl_length()) {
	print_sch(0)
	print "function push_" fnameprefix fnamesuffix "(" (args ? args ", " : "") gfl_join(", ") ", \\\n\t\tidx) {"
	print_sch(1)
	print tabify("        idx = " sym "[" keys lprop "]++")
	i_len = gfl_length()
	for (i=0; i<i_len; i++) {
		field = gfl_get(i)
		print tabify("        " sym "[" keys "idx, \"" field  "\"] = " field)
	}
} else {
	print_sch(0)
	print "function push_" fnameprefix fnamesuffix "(" args ") {"
	print_sch(1)
	print tabify("        " sym "[" keys sym "[" keys lprop "]++] = " value)
}
print "}"
@

<<op length>>=
print "function length_" fnameprefix fnamesuffix "(" args ") {"
print tabify("        return " sym "[" (keys ? keys ", " : "" ) lprop "] + 0")
print "}"
@

<<op get>>=
print "function get_" fnameprefix fnamesuffix "(" args ") {"
print tabify("        return " sym "[" keys "]")
print "}"
@

<<op set>>=
print "function set_" fnameprefix fnamesuffix "(" args ") {"
print tabify("        return " sym "[" keys "] = " value)
print "}"
@

<<op clear>>=
print "function clear_" fnameprefix fnamesuffix "(" args ") {"
print tabify("        return " sym "[" (keys ? keys ", " : "" ) lprop "] = 0")
print "}"
@

<<op lastindex>>=
print "function lastindex_" fnameprefix fnamesuffix "(" args ") {"
print tabify("        return " (idx0 ? idx0 " SUBSEP " : "") "(" sym "[" (idx1 ? idx1 ", " : "" ) lprop "] + 0)")
print "}"
@

<<clean up>>=
sym = ""
operation = ""
fnameprefix = ""
fnamesuffix = ""
args = ""
keys = ""
value = ""
idx0 = ""
idx1 = ""
sch_clean()
gfl_clean()
@

sch - source code hooks

<<source code hooks>>=
function sch_push(num, value) {
	num = num + 0
	sch[num, sch[num, ".len"]++] = value
}
function sch_get(num, \
		res, i, i_len) {
	res = ""
	i_len = sch[num, ".len"] + 0
	for (i=0; i<i_len; i++) {
		res = res "\n" sch[num, i]
	}
	return substr(res, 2);
}
function print_sch(num, \
		tmp) {
	tmp = sch_get(num)
	if (tmp) print tmp;
}
function sch_clean() {
	for (i=0; i<10; i++) {
		sch[i, ".len"] = 0
	}
}
@

<<generic field list>>=
function gfl_push(value) { gfl[gfl[".len"]++] = value }
function gfl_length() { return gfl[".len"] + 0 }
function gfl_get(idx) { return gfl[idx + 0] }
function gfl_clean() { gfl[".len"] = 0; gfl[0] = "" }
function gfl_join(sep, \
		res, i, i_len) {
	res = gfl_get(0)
	i_len = gfl_length()
	for (i=1; i<i_len; i++) {
		res = res sep gfl_get(i)
	}
	return res
}
@

<<generator>>=
BEGIN{ lprop = "\".length\"" }
function tabify(s) { gsub(/        /, "\t", s); return s}

<<source code hooks>>
/^#[0-9]/ { sch_push(substr($0,2,1), substr($0,3)); next }

<<generic field list>>
/^#F/ { gfl_push(substr($0,3)); next }

/^#</ { sym = substr($0,3); fnameprefix = sym; next }
/^#O/ { operation = substr($0,3); next }
/^#P/ { fnameprefix = substr($0,3); next }
/^#S/ { fnamesuffix = substr($0,3); next }
/^#A/ { args = (args ? args ", " : "" ) substr($0,3); next }
/^#K/ { keys = (keys ? keys ", " : "" ) substr($0,3); next }
/^#V/ { value = substr($0,3); next }
/^#I/ {
	idx0 = (idx0 ? idx0 " SUBSEP " : "" ) substr($0,3)
	idx1 = (idx1 ? idx1 ", " : "" ) substr($0,3)
	next
}
/^#>$/ {
	if (operation == "push") {
		<<op push>>
	} else if (operation == "length") {
		<<op length>>
	} else if (operation == "get") {
		<<op get>>
	} else if (operation == "set") {
		<<op set>>
	} else if (operation == "clear") {
		<<op clear>>
	} else if (operation == "lastindex") {
		<<op lastindex>>
	} else if (operation) {
		print "# error: unknown operation: " operation
	} else {
		print "# error: operation not defined"
	}
	<<clean up>>
	next
}
{ print }
@

<<operations>>=
@<<generated@>>=
<<[block]>>
<<block type>>
<<block [output]>>
<<block [chunk]>>
<<block [chunk] name>>
<<block [chunk] target>>
<<block target-option>>
<<block [dependency]>>
<<block [source]>>
<<[chunk]>>
<<[gl0]>>
@@
@

<<[block]>>=

#<block
#Opush
#Aname
#Vname
#>

#<block
#Olength
#>

#<block
#Oget
#Aidx
#Kidx
#>

#<block
#Oset
#Aidx
#Aval
#Kidx
#Vval
#>
@

<<block type>>=

#<block
#Oget
#S__type
#Aname
#Kname
#K"type"
#>

#<block
#Oget
#Pcurrent_block
#S__type
#Kcur_block
#K"type"
#>

#<block
#Oset
#Pcurrent_block
#S__type
#Atype
#Vtype
#Kcur_block
#K"type"
#>
@

<<block [output]>>=

#<block
#Opush
#S_output
#Aname
#Avalue
#Kname
#K"output"
#Vvalue
#1	sub(/^        /, "\t", value)
#>

#<block
#Opush
#Pcurrent_block
#S_output
#Avalue
#Kcur_block
#K"output"
#Vvalue
#1	sub(/^        /, "\t", value)
#>

#<block
#Olength
#S_output
#Ablock_name
#Kblock_name
#K"output"
#>

#<block
#Oget
#S_output
#Ablock_name
#Aidx
#Kblock_name
#K"output"
#Kidx
#>
@

<<block [chunk]>>=

#<block
#Opush
#Pcurrent_block
#S_chunk
#Fname
#Ftarget
#Kcur_block
#K"chunk"
#>

#<block
#Olength
#S_chunk
#Ablock_name
#Kblock_name
#K"chunk"
#>
@

<<block [chunk] name>>=

#<block
#Oget
#Pcurrent_block
#S_chunk__name
#Aidx
#Kcur_block
#K"chunk"
#Kidx
#K"name"
#>
@

<<block [chunk] target>>=

#<block
#Oget
#Pcurrent_block
#S_chunk__target
#Aidx
#Kcur_block
#K"chunk"
#Kidx
#K"target"
#>
@

<<block target-option>>=

#<block
#Oset
#Pcurrent_block
#S_targetoption
#Atarget
#Aoption
#Avalue
#Vvalue
#Kcur_block
#K"target-option"
#Ktarget
#Koption
#>

#<block
#Oget
#Pcurrent_block
#S_targetoption
#Atarget
#Aoption
#Kcur_block
#K"target-option"
#Ktarget
#Koption
#>
@

<<block [dependency]>>=

#<block
#Opush
#Pcurrent_block
#S_dependency
#Aname
#Vname
#Kcur_block
#K"dependency"
#>

#<block
#Olength
#S_dependency
#Ablock_name
#Kblock_name
#K"dependency"
#>

#<block
#Oget
#S_dependency
#Ablock_name
#Aidx
#Kblock_name
#K"dependency"
#Kidx
#>
@

<<block [source]>>=

#<block
#Opush
#Pcurrent_block
#S_source
#Asource
#Vsource
#Kcur_block
#K"source"
#>

#<block
#Olength
#S_source
#Ablock_name
#Kblock_name
#K"source"
#>

#<block
#Oget
#S_source
#Ablock_name
#Aidx
#Kblock_name
#K"source"
#Kidx
#>
@

<<[chunk]>>=

#<chunk
#Opush
#Fname
#Ftarget
#>

#<chunk
#Olength
#>

# target is unique among blocks and chunks

#<chunk
#Oget
#S__target
#Aidx
#Kidx
#K"target"
#>
@

<<[gl0]>>=

# generic list 0, for local, temporary uses

#<gl0
#Opush
#Aitem
#Vitem
#>

#<gl0
#Olength
#>

#<gl0
#Oget
#Aidx
#Kidx
#>

#<gl0
#Oclear
#>
@
